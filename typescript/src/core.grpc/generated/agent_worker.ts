// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v5.29.3
// source: agent_worker.proto

/* eslint-disable */
import {
  type CallOptions,
  ChannelCredentials,
  Client,
  ClientDuplexStream,
  type ClientOptions,
  type ClientUnaryCall,
  handleBidiStreamingCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";
import _m0 from "protobufjs/minimal";
import { CloudEvent } from "./cloudevent";
import { Any } from "./google/protobuf/any";

export const protobufPackage = "agents";

export interface AgentId {
  type: string;
  key: string;
}

export interface Payload {
  dataType: string;
  dataContentType: string;
  data: Buffer;
}

export interface RpcRequest {
  requestId: string;
  source?: AgentId | undefined;
  target: AgentId | undefined;
  method: string;
  payload: Payload | undefined;
  metadata: { [key: string]: string };
}

export interface RpcRequest_MetadataEntry {
  key: string;
  value: string;
}

export interface RpcResponse {
  requestId: string;
  payload: Payload | undefined;
  error: string;
  metadata: { [key: string]: string };
}

export interface RpcResponse_MetadataEntry {
  key: string;
  value: string;
}

export interface RegisterAgentTypeRequest {
  type: string;
}

export interface RegisterAgentTypeResponse {}

export interface TypeSubscription {
  topicType: string;
  agentType: string;
}

export interface TypePrefixSubscription {
  topicTypePrefix: string;
  agentType: string;
}

export interface Subscription {
  id: string;
  typeSubscription?: TypeSubscription | undefined;
  typePrefixSubscription?: TypePrefixSubscription | undefined;
}

export interface AddSubscriptionRequest {
  subscription: Subscription | undefined;
}

export interface AddSubscriptionResponse {}

export interface RemoveSubscriptionRequest {
  id: string;
}

export interface RemoveSubscriptionResponse {}

export interface GetSubscriptionsRequest {}

export interface GetSubscriptionsResponse {
  subscriptions: Subscription[];
}

export interface Message {
  request?: RpcRequest | undefined;
  response?: RpcResponse | undefined;
  cloudEvent?: CloudEvent | undefined;
}

export interface SaveStateRequest {
  agentId: AgentId | undefined;
}

export interface SaveStateResponse {
  state: string;
  error?: string | undefined;
}

export interface LoadStateRequest {
  agentId: AgentId | undefined;
  state: string;
}

export interface LoadStateResponse {
  error?: string | undefined;
}

export interface ControlMessage {
  /** A response message should have the same id as the request message */
  rpcId: string;
  /**
   * This is either:
   * agentid=AGENT_ID
   * clientid=CLIENT_ID
   */
  destination: string;
  /**
   * This is either:
   * agentid=AGENT_ID
   * clientid=CLIENT_ID
   * Empty string means the message is a response
   */
  respondTo?: string | undefined;
  /**
   * One of:
   *     SaveStateRequest saveStateRequest = 2;
   *     SaveStateResponse saveStateResponse = 3;
   *     LoadStateRequest loadStateRequest = 4;
   *     LoadStateResponse loadStateResponse = 5;
   */
  rpcMessage: Any | undefined;
}

function createBaseAgentId(): AgentId {
  return { type: "", key: "" };
}

export const AgentId = {
  encode(
    message: AgentId,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.type !== "") {
      writer.uint32(10).string(message.type);
    }
    if (message.key !== "") {
      writer.uint32(18).string(message.key);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AgentId {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAgentId();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.type = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.key = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AgentId {
    return {
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      key: isSet(object.key) ? globalThis.String(object.key) : "",
    };
  },

  toJSON(message: AgentId): unknown {
    const obj: any = {};
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.key !== "") {
      obj.key = message.key;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AgentId>, I>>(base?: I): AgentId {
    return AgentId.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AgentId>, I>>(object: I): AgentId {
    const message = createBaseAgentId();
    message.type = object.type ?? "";
    message.key = object.key ?? "";
    return message;
  },
};

function createBasePayload(): Payload {
  return { dataType: "", dataContentType: "", data: Buffer.alloc(0) };
}

export const Payload = {
  encode(
    message: Payload,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.dataType !== "") {
      writer.uint32(10).string(message.dataType);
    }
    if (message.dataContentType !== "") {
      writer.uint32(18).string(message.dataContentType);
    }
    if (message.data.length !== 0) {
      writer.uint32(26).bytes(message.data);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Payload {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePayload();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.dataType = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.dataContentType = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.data = reader.bytes() as Buffer;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Payload {
    return {
      dataType: isSet(object.dataType)
        ? globalThis.String(object.dataType)
        : "",
      dataContentType: isSet(object.dataContentType)
        ? globalThis.String(object.dataContentType)
        : "",
      data: isSet(object.data)
        ? Buffer.from(bytesFromBase64(object.data))
        : Buffer.alloc(0),
    };
  },

  toJSON(message: Payload): unknown {
    const obj: any = {};
    if (message.dataType !== "") {
      obj.dataType = message.dataType;
    }
    if (message.dataContentType !== "") {
      obj.dataContentType = message.dataContentType;
    }
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Payload>, I>>(base?: I): Payload {
    return Payload.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Payload>, I>>(object: I): Payload {
    const message = createBasePayload();
    message.dataType = object.dataType ?? "";
    message.dataContentType = object.dataContentType ?? "";
    message.data = object.data ?? Buffer.alloc(0);
    return message;
  },
};

function createBaseRpcRequest(): RpcRequest {
  return {
    requestId: "",
    source: undefined,
    target: undefined,
    method: "",
    payload: undefined,
    metadata: {},
  };
}

export const RpcRequest = {
  encode(
    message: RpcRequest,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.requestId !== "") {
      writer.uint32(10).string(message.requestId);
    }
    if (message.source !== undefined) {
      AgentId.encode(message.source, writer.uint32(18).fork()).ldelim();
    }
    if (message.target !== undefined) {
      AgentId.encode(message.target, writer.uint32(26).fork()).ldelim();
    }
    if (message.method !== "") {
      writer.uint32(34).string(message.method);
    }
    if (message.payload !== undefined) {
      Payload.encode(message.payload, writer.uint32(42).fork()).ldelim();
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      RpcRequest_MetadataEntry.encode(
        { key: key as any, value },
        writer.uint32(50).fork(),
      ).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RpcRequest {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRpcRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.requestId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.source = AgentId.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.target = AgentId.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.method = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.payload = Payload.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          const entry6 = RpcRequest_MetadataEntry.decode(
            reader,
            reader.uint32(),
          );
          if (entry6.value !== undefined) {
            message.metadata[entry6.key] = entry6.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RpcRequest {
    return {
      requestId: isSet(object.requestId)
        ? globalThis.String(object.requestId)
        : "",
      source: isSet(object.source)
        ? AgentId.fromJSON(object.source)
        : undefined,
      target: isSet(object.target)
        ? AgentId.fromJSON(object.target)
        : undefined,
      method: isSet(object.method) ? globalThis.String(object.method) : "",
      payload: isSet(object.payload)
        ? Payload.fromJSON(object.payload)
        : undefined,
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>(
            (acc, [key, value]) => {
              acc[key] = String(value);
              return acc;
            },
            {},
          )
        : {},
    };
  },

  toJSON(message: RpcRequest): unknown {
    const obj: any = {};
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    if (message.source !== undefined) {
      obj.source = AgentId.toJSON(message.source);
    }
    if (message.target !== undefined) {
      obj.target = AgentId.toJSON(message.target);
    }
    if (message.method !== "") {
      obj.method = message.method;
    }
    if (message.payload !== undefined) {
      obj.payload = Payload.toJSON(message.payload);
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RpcRequest>, I>>(base?: I): RpcRequest {
    return RpcRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RpcRequest>, I>>(
    object: I,
  ): RpcRequest {
    const message = createBaseRpcRequest();
    message.requestId = object.requestId ?? "";
    message.source =
      object.source !== undefined && object.source !== null
        ? AgentId.fromPartial(object.source)
        : undefined;
    message.target =
      object.target !== undefined && object.target !== null
        ? AgentId.fromPartial(object.target)
        : undefined;
    message.method = object.method ?? "";
    message.payload =
      object.payload !== undefined && object.payload !== null
        ? Payload.fromPartial(object.payload)
        : undefined;
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{
      [key: string]: string;
    }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseRpcRequest_MetadataEntry(): RpcRequest_MetadataEntry {
  return { key: "", value: "" };
}

export const RpcRequest_MetadataEntry = {
  encode(
    message: RpcRequest_MetadataEntry,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number,
  ): RpcRequest_MetadataEntry {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRpcRequest_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RpcRequest_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: RpcRequest_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RpcRequest_MetadataEntry>, I>>(
    base?: I,
  ): RpcRequest_MetadataEntry {
    return RpcRequest_MetadataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RpcRequest_MetadataEntry>, I>>(
    object: I,
  ): RpcRequest_MetadataEntry {
    const message = createBaseRpcRequest_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseRpcResponse(): RpcResponse {
  return { requestId: "", payload: undefined, error: "", metadata: {} };
}

export const RpcResponse = {
  encode(
    message: RpcResponse,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.requestId !== "") {
      writer.uint32(10).string(message.requestId);
    }
    if (message.payload !== undefined) {
      Payload.encode(message.payload, writer.uint32(18).fork()).ldelim();
    }
    if (message.error !== "") {
      writer.uint32(26).string(message.error);
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      RpcResponse_MetadataEntry.encode(
        { key: key as any, value },
        writer.uint32(34).fork(),
      ).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RpcResponse {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRpcResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.requestId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.payload = Payload.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.error = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          const entry4 = RpcResponse_MetadataEntry.decode(
            reader,
            reader.uint32(),
          );
          if (entry4.value !== undefined) {
            message.metadata[entry4.key] = entry4.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RpcResponse {
    return {
      requestId: isSet(object.requestId)
        ? globalThis.String(object.requestId)
        : "",
      payload: isSet(object.payload)
        ? Payload.fromJSON(object.payload)
        : undefined,
      error: isSet(object.error) ? globalThis.String(object.error) : "",
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>(
            (acc, [key, value]) => {
              acc[key] = String(value);
              return acc;
            },
            {},
          )
        : {},
    };
  },

  toJSON(message: RpcResponse): unknown {
    const obj: any = {};
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    if (message.payload !== undefined) {
      obj.payload = Payload.toJSON(message.payload);
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RpcResponse>, I>>(base?: I): RpcResponse {
    return RpcResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RpcResponse>, I>>(
    object: I,
  ): RpcResponse {
    const message = createBaseRpcResponse();
    message.requestId = object.requestId ?? "";
    message.payload =
      object.payload !== undefined && object.payload !== null
        ? Payload.fromPartial(object.payload)
        : undefined;
    message.error = object.error ?? "";
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{
      [key: string]: string;
    }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseRpcResponse_MetadataEntry(): RpcResponse_MetadataEntry {
  return { key: "", value: "" };
}

export const RpcResponse_MetadataEntry = {
  encode(
    message: RpcResponse_MetadataEntry,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number,
  ): RpcResponse_MetadataEntry {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRpcResponse_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RpcResponse_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: RpcResponse_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RpcResponse_MetadataEntry>, I>>(
    base?: I,
  ): RpcResponse_MetadataEntry {
    return RpcResponse_MetadataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RpcResponse_MetadataEntry>, I>>(
    object: I,
  ): RpcResponse_MetadataEntry {
    const message = createBaseRpcResponse_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseRegisterAgentTypeRequest(): RegisterAgentTypeRequest {
  return { type: "" };
}

export const RegisterAgentTypeRequest = {
  encode(
    message: RegisterAgentTypeRequest,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.type !== "") {
      writer.uint32(10).string(message.type);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number,
  ): RegisterAgentTypeRequest {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRegisterAgentTypeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.type = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RegisterAgentTypeRequest {
    return { type: isSet(object.type) ? globalThis.String(object.type) : "" };
  },

  toJSON(message: RegisterAgentTypeRequest): unknown {
    const obj: any = {};
    if (message.type !== "") {
      obj.type = message.type;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RegisterAgentTypeRequest>, I>>(
    base?: I,
  ): RegisterAgentTypeRequest {
    return RegisterAgentTypeRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RegisterAgentTypeRequest>, I>>(
    object: I,
  ): RegisterAgentTypeRequest {
    const message = createBaseRegisterAgentTypeRequest();
    message.type = object.type ?? "";
    return message;
  },
};

function createBaseRegisterAgentTypeResponse(): RegisterAgentTypeResponse {
  return {};
}

export const RegisterAgentTypeResponse = {
  encode(
    _: RegisterAgentTypeResponse,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number,
  ): RegisterAgentTypeResponse {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRegisterAgentTypeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): RegisterAgentTypeResponse {
    return {};
  },

  toJSON(_: RegisterAgentTypeResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<RegisterAgentTypeResponse>, I>>(
    base?: I,
  ): RegisterAgentTypeResponse {
    return RegisterAgentTypeResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RegisterAgentTypeResponse>, I>>(
    _: I,
  ): RegisterAgentTypeResponse {
    const message = createBaseRegisterAgentTypeResponse();
    return message;
  },
};

function createBaseTypeSubscription(): TypeSubscription {
  return { topicType: "", agentType: "" };
}

export const TypeSubscription = {
  encode(
    message: TypeSubscription,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.topicType !== "") {
      writer.uint32(10).string(message.topicType);
    }
    if (message.agentType !== "") {
      writer.uint32(18).string(message.agentType);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TypeSubscription {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTypeSubscription();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.topicType = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.agentType = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TypeSubscription {
    return {
      topicType: isSet(object.topicType)
        ? globalThis.String(object.topicType)
        : "",
      agentType: isSet(object.agentType)
        ? globalThis.String(object.agentType)
        : "",
    };
  },

  toJSON(message: TypeSubscription): unknown {
    const obj: any = {};
    if (message.topicType !== "") {
      obj.topicType = message.topicType;
    }
    if (message.agentType !== "") {
      obj.agentType = message.agentType;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TypeSubscription>, I>>(
    base?: I,
  ): TypeSubscription {
    return TypeSubscription.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TypeSubscription>, I>>(
    object: I,
  ): TypeSubscription {
    const message = createBaseTypeSubscription();
    message.topicType = object.topicType ?? "";
    message.agentType = object.agentType ?? "";
    return message;
  },
};

function createBaseTypePrefixSubscription(): TypePrefixSubscription {
  return { topicTypePrefix: "", agentType: "" };
}

export const TypePrefixSubscription = {
  encode(
    message: TypePrefixSubscription,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.topicTypePrefix !== "") {
      writer.uint32(10).string(message.topicTypePrefix);
    }
    if (message.agentType !== "") {
      writer.uint32(18).string(message.agentType);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number,
  ): TypePrefixSubscription {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTypePrefixSubscription();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.topicTypePrefix = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.agentType = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TypePrefixSubscription {
    return {
      topicTypePrefix: isSet(object.topicTypePrefix)
        ? globalThis.String(object.topicTypePrefix)
        : "",
      agentType: isSet(object.agentType)
        ? globalThis.String(object.agentType)
        : "",
    };
  },

  toJSON(message: TypePrefixSubscription): unknown {
    const obj: any = {};
    if (message.topicTypePrefix !== "") {
      obj.topicTypePrefix = message.topicTypePrefix;
    }
    if (message.agentType !== "") {
      obj.agentType = message.agentType;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TypePrefixSubscription>, I>>(
    base?: I,
  ): TypePrefixSubscription {
    return TypePrefixSubscription.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TypePrefixSubscription>, I>>(
    object: I,
  ): TypePrefixSubscription {
    const message = createBaseTypePrefixSubscription();
    message.topicTypePrefix = object.topicTypePrefix ?? "";
    message.agentType = object.agentType ?? "";
    return message;
  },
};

function createBaseSubscription(): Subscription {
  return {
    id: "",
    typeSubscription: undefined,
    typePrefixSubscription: undefined,
  };
}

export const Subscription = {
  encode(
    message: Subscription,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.typeSubscription !== undefined) {
      TypeSubscription.encode(
        message.typeSubscription,
        writer.uint32(18).fork(),
      ).ldelim();
    }
    if (message.typePrefixSubscription !== undefined) {
      TypePrefixSubscription.encode(
        message.typePrefixSubscription,
        writer.uint32(26).fork(),
      ).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Subscription {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubscription();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.typeSubscription = TypeSubscription.decode(
            reader,
            reader.uint32(),
          );
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.typePrefixSubscription = TypePrefixSubscription.decode(
            reader,
            reader.uint32(),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Subscription {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      typeSubscription: isSet(object.typeSubscription)
        ? TypeSubscription.fromJSON(object.typeSubscription)
        : undefined,
      typePrefixSubscription: isSet(object.typePrefixSubscription)
        ? TypePrefixSubscription.fromJSON(object.typePrefixSubscription)
        : undefined,
    };
  },

  toJSON(message: Subscription): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.typeSubscription !== undefined) {
      obj.typeSubscription = TypeSubscription.toJSON(message.typeSubscription);
    }
    if (message.typePrefixSubscription !== undefined) {
      obj.typePrefixSubscription = TypePrefixSubscription.toJSON(
        message.typePrefixSubscription,
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Subscription>, I>>(
    base?: I,
  ): Subscription {
    return Subscription.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Subscription>, I>>(
    object: I,
  ): Subscription {
    const message = createBaseSubscription();
    message.id = object.id ?? "";
    message.typeSubscription =
      object.typeSubscription !== undefined && object.typeSubscription !== null
        ? TypeSubscription.fromPartial(object.typeSubscription)
        : undefined;
    message.typePrefixSubscription =
      object.typePrefixSubscription !== undefined &&
      object.typePrefixSubscription !== null
        ? TypePrefixSubscription.fromPartial(object.typePrefixSubscription)
        : undefined;
    return message;
  },
};

function createBaseAddSubscriptionRequest(): AddSubscriptionRequest {
  return { subscription: undefined };
}

export const AddSubscriptionRequest = {
  encode(
    message: AddSubscriptionRequest,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.subscription !== undefined) {
      Subscription.encode(
        message.subscription,
        writer.uint32(10).fork(),
      ).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number,
  ): AddSubscriptionRequest {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddSubscriptionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.subscription = Subscription.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddSubscriptionRequest {
    return {
      subscription: isSet(object.subscription)
        ? Subscription.fromJSON(object.subscription)
        : undefined,
    };
  },

  toJSON(message: AddSubscriptionRequest): unknown {
    const obj: any = {};
    if (message.subscription !== undefined) {
      obj.subscription = Subscription.toJSON(message.subscription);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AddSubscriptionRequest>, I>>(
    base?: I,
  ): AddSubscriptionRequest {
    return AddSubscriptionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AddSubscriptionRequest>, I>>(
    object: I,
  ): AddSubscriptionRequest {
    const message = createBaseAddSubscriptionRequest();
    message.subscription =
      object.subscription !== undefined && object.subscription !== null
        ? Subscription.fromPartial(object.subscription)
        : undefined;
    return message;
  },
};

function createBaseAddSubscriptionResponse(): AddSubscriptionResponse {
  return {};
}

export const AddSubscriptionResponse = {
  encode(
    _: AddSubscriptionResponse,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number,
  ): AddSubscriptionResponse {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddSubscriptionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): AddSubscriptionResponse {
    return {};
  },

  toJSON(_: AddSubscriptionResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<AddSubscriptionResponse>, I>>(
    base?: I,
  ): AddSubscriptionResponse {
    return AddSubscriptionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AddSubscriptionResponse>, I>>(
    _: I,
  ): AddSubscriptionResponse {
    const message = createBaseAddSubscriptionResponse();
    return message;
  },
};

function createBaseRemoveSubscriptionRequest(): RemoveSubscriptionRequest {
  return { id: "" };
}

export const RemoveSubscriptionRequest = {
  encode(
    message: RemoveSubscriptionRequest,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number,
  ): RemoveSubscriptionRequest {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRemoveSubscriptionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RemoveSubscriptionRequest {
    return { id: isSet(object.id) ? globalThis.String(object.id) : "" };
  },

  toJSON(message: RemoveSubscriptionRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RemoveSubscriptionRequest>, I>>(
    base?: I,
  ): RemoveSubscriptionRequest {
    return RemoveSubscriptionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RemoveSubscriptionRequest>, I>>(
    object: I,
  ): RemoveSubscriptionRequest {
    const message = createBaseRemoveSubscriptionRequest();
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseRemoveSubscriptionResponse(): RemoveSubscriptionResponse {
  return {};
}

export const RemoveSubscriptionResponse = {
  encode(
    _: RemoveSubscriptionResponse,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number,
  ): RemoveSubscriptionResponse {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRemoveSubscriptionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): RemoveSubscriptionResponse {
    return {};
  },

  toJSON(_: RemoveSubscriptionResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<RemoveSubscriptionResponse>, I>>(
    base?: I,
  ): RemoveSubscriptionResponse {
    return RemoveSubscriptionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RemoveSubscriptionResponse>, I>>(
    _: I,
  ): RemoveSubscriptionResponse {
    const message = createBaseRemoveSubscriptionResponse();
    return message;
  },
};

function createBaseGetSubscriptionsRequest(): GetSubscriptionsRequest {
  return {};
}

export const GetSubscriptionsRequest = {
  encode(
    _: GetSubscriptionsRequest,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number,
  ): GetSubscriptionsRequest {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSubscriptionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GetSubscriptionsRequest {
    return {};
  },

  toJSON(_: GetSubscriptionsRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<GetSubscriptionsRequest>, I>>(
    base?: I,
  ): GetSubscriptionsRequest {
    return GetSubscriptionsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetSubscriptionsRequest>, I>>(
    _: I,
  ): GetSubscriptionsRequest {
    const message = createBaseGetSubscriptionsRequest();
    return message;
  },
};

function createBaseGetSubscriptionsResponse(): GetSubscriptionsResponse {
  return { subscriptions: [] };
}

export const GetSubscriptionsResponse = {
  encode(
    message: GetSubscriptionsResponse,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    for (const v of message.subscriptions) {
      Subscription.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number,
  ): GetSubscriptionsResponse {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSubscriptionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.subscriptions.push(
            Subscription.decode(reader, reader.uint32()),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetSubscriptionsResponse {
    return {
      subscriptions: globalThis.Array.isArray(object?.subscriptions)
        ? object.subscriptions.map((e: any) => Subscription.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetSubscriptionsResponse): unknown {
    const obj: any = {};
    if (message.subscriptions?.length) {
      obj.subscriptions = message.subscriptions.map((e) =>
        Subscription.toJSON(e),
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetSubscriptionsResponse>, I>>(
    base?: I,
  ): GetSubscriptionsResponse {
    return GetSubscriptionsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetSubscriptionsResponse>, I>>(
    object: I,
  ): GetSubscriptionsResponse {
    const message = createBaseGetSubscriptionsResponse();
    message.subscriptions =
      object.subscriptions?.map((e) => Subscription.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMessage(): Message {
  return { request: undefined, response: undefined, cloudEvent: undefined };
}

export const Message = {
  encode(
    message: Message,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.request !== undefined) {
      RpcRequest.encode(message.request, writer.uint32(10).fork()).ldelim();
    }
    if (message.response !== undefined) {
      RpcResponse.encode(message.response, writer.uint32(18).fork()).ldelim();
    }
    if (message.cloudEvent !== undefined) {
      CloudEvent.encode(message.cloudEvent, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Message {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.request = RpcRequest.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.response = RpcResponse.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.cloudEvent = CloudEvent.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Message {
    return {
      request: isSet(object.request)
        ? RpcRequest.fromJSON(object.request)
        : undefined,
      response: isSet(object.response)
        ? RpcResponse.fromJSON(object.response)
        : undefined,
      cloudEvent: isSet(object.cloudEvent)
        ? CloudEvent.fromJSON(object.cloudEvent)
        : undefined,
    };
  },

  toJSON(message: Message): unknown {
    const obj: any = {};
    if (message.request !== undefined) {
      obj.request = RpcRequest.toJSON(message.request);
    }
    if (message.response !== undefined) {
      obj.response = RpcResponse.toJSON(message.response);
    }
    if (message.cloudEvent !== undefined) {
      obj.cloudEvent = CloudEvent.toJSON(message.cloudEvent);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Message>, I>>(base?: I): Message {
    return Message.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Message>, I>>(object: I): Message {
    const message = createBaseMessage();
    message.request =
      object.request !== undefined && object.request !== null
        ? RpcRequest.fromPartial(object.request)
        : undefined;
    message.response =
      object.response !== undefined && object.response !== null
        ? RpcResponse.fromPartial(object.response)
        : undefined;
    message.cloudEvent =
      object.cloudEvent !== undefined && object.cloudEvent !== null
        ? CloudEvent.fromPartial(object.cloudEvent)
        : undefined;
    return message;
  },
};

function createBaseSaveStateRequest(): SaveStateRequest {
  return { agentId: undefined };
}

export const SaveStateRequest = {
  encode(
    message: SaveStateRequest,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.agentId !== undefined) {
      AgentId.encode(message.agentId, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SaveStateRequest {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSaveStateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.agentId = AgentId.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SaveStateRequest {
    return {
      agentId: isSet(object.agentId)
        ? AgentId.fromJSON(object.agentId)
        : undefined,
    };
  },

  toJSON(message: SaveStateRequest): unknown {
    const obj: any = {};
    if (message.agentId !== undefined) {
      obj.agentId = AgentId.toJSON(message.agentId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SaveStateRequest>, I>>(
    base?: I,
  ): SaveStateRequest {
    return SaveStateRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SaveStateRequest>, I>>(
    object: I,
  ): SaveStateRequest {
    const message = createBaseSaveStateRequest();
    message.agentId =
      object.agentId !== undefined && object.agentId !== null
        ? AgentId.fromPartial(object.agentId)
        : undefined;
    return message;
  },
};

function createBaseSaveStateResponse(): SaveStateResponse {
  return { state: "", error: undefined };
}

export const SaveStateResponse = {
  encode(
    message: SaveStateResponse,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.state !== "") {
      writer.uint32(10).string(message.state);
    }
    if (message.error !== undefined) {
      writer.uint32(18).string(message.error);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SaveStateResponse {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSaveStateResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.state = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.error = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SaveStateResponse {
    return {
      state: isSet(object.state) ? globalThis.String(object.state) : "",
      error: isSet(object.error) ? globalThis.String(object.error) : undefined,
    };
  },

  toJSON(message: SaveStateResponse): unknown {
    const obj: any = {};
    if (message.state !== "") {
      obj.state = message.state;
    }
    if (message.error !== undefined) {
      obj.error = message.error;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SaveStateResponse>, I>>(
    base?: I,
  ): SaveStateResponse {
    return SaveStateResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SaveStateResponse>, I>>(
    object: I,
  ): SaveStateResponse {
    const message = createBaseSaveStateResponse();
    message.state = object.state ?? "";
    message.error = object.error ?? undefined;
    return message;
  },
};

function createBaseLoadStateRequest(): LoadStateRequest {
  return { agentId: undefined, state: "" };
}

export const LoadStateRequest = {
  encode(
    message: LoadStateRequest,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.agentId !== undefined) {
      AgentId.encode(message.agentId, writer.uint32(10).fork()).ldelim();
    }
    if (message.state !== "") {
      writer.uint32(18).string(message.state);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): LoadStateRequest {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLoadStateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.agentId = AgentId.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.state = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LoadStateRequest {
    return {
      agentId: isSet(object.agentId)
        ? AgentId.fromJSON(object.agentId)
        : undefined,
      state: isSet(object.state) ? globalThis.String(object.state) : "",
    };
  },

  toJSON(message: LoadStateRequest): unknown {
    const obj: any = {};
    if (message.agentId !== undefined) {
      obj.agentId = AgentId.toJSON(message.agentId);
    }
    if (message.state !== "") {
      obj.state = message.state;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LoadStateRequest>, I>>(
    base?: I,
  ): LoadStateRequest {
    return LoadStateRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LoadStateRequest>, I>>(
    object: I,
  ): LoadStateRequest {
    const message = createBaseLoadStateRequest();
    message.agentId =
      object.agentId !== undefined && object.agentId !== null
        ? AgentId.fromPartial(object.agentId)
        : undefined;
    message.state = object.state ?? "";
    return message;
  },
};

function createBaseLoadStateResponse(): LoadStateResponse {
  return { error: undefined };
}

export const LoadStateResponse = {
  encode(
    message: LoadStateResponse,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.error !== undefined) {
      writer.uint32(10).string(message.error);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): LoadStateResponse {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLoadStateResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.error = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LoadStateResponse {
    return {
      error: isSet(object.error) ? globalThis.String(object.error) : undefined,
    };
  },

  toJSON(message: LoadStateResponse): unknown {
    const obj: any = {};
    if (message.error !== undefined) {
      obj.error = message.error;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LoadStateResponse>, I>>(
    base?: I,
  ): LoadStateResponse {
    return LoadStateResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LoadStateResponse>, I>>(
    object: I,
  ): LoadStateResponse {
    const message = createBaseLoadStateResponse();
    message.error = object.error ?? undefined;
    return message;
  },
};

function createBaseControlMessage(): ControlMessage {
  return {
    rpcId: "",
    destination: "",
    respondTo: undefined,
    rpcMessage: undefined,
  };
}

export const ControlMessage = {
  encode(
    message: ControlMessage,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.rpcId !== "") {
      writer.uint32(10).string(message.rpcId);
    }
    if (message.destination !== "") {
      writer.uint32(18).string(message.destination);
    }
    if (message.respondTo !== undefined) {
      writer.uint32(26).string(message.respondTo);
    }
    if (message.rpcMessage !== undefined) {
      Any.encode(message.rpcMessage, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ControlMessage {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseControlMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.rpcId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.destination = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.respondTo = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.rpcMessage = Any.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ControlMessage {
    return {
      rpcId: isSet(object.rpcId) ? globalThis.String(object.rpcId) : "",
      destination: isSet(object.destination)
        ? globalThis.String(object.destination)
        : "",
      respondTo: isSet(object.respondTo)
        ? globalThis.String(object.respondTo)
        : undefined,
      rpcMessage: isSet(object.rpcMessage)
        ? Any.fromJSON(object.rpcMessage)
        : undefined,
    };
  },

  toJSON(message: ControlMessage): unknown {
    const obj: any = {};
    if (message.rpcId !== "") {
      obj.rpcId = message.rpcId;
    }
    if (message.destination !== "") {
      obj.destination = message.destination;
    }
    if (message.respondTo !== undefined) {
      obj.respondTo = message.respondTo;
    }
    if (message.rpcMessage !== undefined) {
      obj.rpcMessage = Any.toJSON(message.rpcMessage);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ControlMessage>, I>>(
    base?: I,
  ): ControlMessage {
    return ControlMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ControlMessage>, I>>(
    object: I,
  ): ControlMessage {
    const message = createBaseControlMessage();
    message.rpcId = object.rpcId ?? "";
    message.destination = object.destination ?? "";
    message.respondTo = object.respondTo ?? undefined;
    message.rpcMessage =
      object.rpcMessage !== undefined && object.rpcMessage !== null
        ? Any.fromPartial(object.rpcMessage)
        : undefined;
    return message;
  },
};

export type AgentRpcService = typeof AgentRpcService;
export const AgentRpcService = {
  openChannel: {
    path: "/agents.AgentRpc/OpenChannel",
    requestStream: true,
    responseStream: true,
    requestSerialize: (value: Message) =>
      Buffer.from(Message.encode(value).finish()),
    requestDeserialize: (value: Buffer) => Message.decode(value),
    responseSerialize: (value: Message) =>
      Buffer.from(Message.encode(value).finish()),
    responseDeserialize: (value: Buffer) => Message.decode(value),
  },
  openControlChannel: {
    path: "/agents.AgentRpc/OpenControlChannel",
    requestStream: true,
    responseStream: true,
    requestSerialize: (value: ControlMessage) =>
      Buffer.from(ControlMessage.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ControlMessage.decode(value),
    responseSerialize: (value: ControlMessage) =>
      Buffer.from(ControlMessage.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ControlMessage.decode(value),
  },
  registerAgent: {
    path: "/agents.AgentRpc/RegisterAgent",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: RegisterAgentTypeRequest) =>
      Buffer.from(RegisterAgentTypeRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) =>
      RegisterAgentTypeRequest.decode(value),
    responseSerialize: (value: RegisterAgentTypeResponse) =>
      Buffer.from(RegisterAgentTypeResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) =>
      RegisterAgentTypeResponse.decode(value),
  },
  addSubscription: {
    path: "/agents.AgentRpc/AddSubscription",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: AddSubscriptionRequest) =>
      Buffer.from(AddSubscriptionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => AddSubscriptionRequest.decode(value),
    responseSerialize: (value: AddSubscriptionResponse) =>
      Buffer.from(AddSubscriptionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) =>
      AddSubscriptionResponse.decode(value),
  },
  removeSubscription: {
    path: "/agents.AgentRpc/RemoveSubscription",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: RemoveSubscriptionRequest) =>
      Buffer.from(RemoveSubscriptionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) =>
      RemoveSubscriptionRequest.decode(value),
    responseSerialize: (value: RemoveSubscriptionResponse) =>
      Buffer.from(RemoveSubscriptionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) =>
      RemoveSubscriptionResponse.decode(value),
  },
  getSubscriptions: {
    path: "/agents.AgentRpc/GetSubscriptions",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetSubscriptionsRequest) =>
      Buffer.from(GetSubscriptionsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) =>
      GetSubscriptionsRequest.decode(value),
    responseSerialize: (value: GetSubscriptionsResponse) =>
      Buffer.from(GetSubscriptionsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) =>
      GetSubscriptionsResponse.decode(value),
  },
} as const;

export interface AgentRpcServer extends UntypedServiceImplementation {
  openChannel: handleBidiStreamingCall<Message, Message>;
  openControlChannel: handleBidiStreamingCall<ControlMessage, ControlMessage>;
  registerAgent: handleUnaryCall<
    RegisterAgentTypeRequest,
    RegisterAgentTypeResponse
  >;
  addSubscription: handleUnaryCall<
    AddSubscriptionRequest,
    AddSubscriptionResponse
  >;
  removeSubscription: handleUnaryCall<
    RemoveSubscriptionRequest,
    RemoveSubscriptionResponse
  >;
  getSubscriptions: handleUnaryCall<
    GetSubscriptionsRequest,
    GetSubscriptionsResponse
  >;
}

export interface AgentRpcClient extends Client {
  openChannel(): ClientDuplexStream<Message, Message>;
  openChannel(
    options: Partial<CallOptions>,
  ): ClientDuplexStream<Message, Message>;
  openChannel(
    metadata: Metadata,
    options?: Partial<CallOptions>,
  ): ClientDuplexStream<Message, Message>;
  openControlChannel(): ClientDuplexStream<ControlMessage, ControlMessage>;
  openControlChannel(
    options: Partial<CallOptions>,
  ): ClientDuplexStream<ControlMessage, ControlMessage>;
  openControlChannel(
    metadata: Metadata,
    options?: Partial<CallOptions>,
  ): ClientDuplexStream<ControlMessage, ControlMessage>;
  registerAgent(
    request: RegisterAgentTypeRequest,
    callback: (
      error: ServiceError | null,
      response: RegisterAgentTypeResponse,
    ) => void,
  ): ClientUnaryCall;
  registerAgent(
    request: RegisterAgentTypeRequest,
    metadata: Metadata,
    callback: (
      error: ServiceError | null,
      response: RegisterAgentTypeResponse,
    ) => void,
  ): ClientUnaryCall;
  registerAgent(
    request: RegisterAgentTypeRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (
      error: ServiceError | null,
      response: RegisterAgentTypeResponse,
    ) => void,
  ): ClientUnaryCall;
  addSubscription(
    request: AddSubscriptionRequest,
    callback: (
      error: ServiceError | null,
      response: AddSubscriptionResponse,
    ) => void,
  ): ClientUnaryCall;
  addSubscription(
    request: AddSubscriptionRequest,
    metadata: Metadata,
    callback: (
      error: ServiceError | null,
      response: AddSubscriptionResponse,
    ) => void,
  ): ClientUnaryCall;
  addSubscription(
    request: AddSubscriptionRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (
      error: ServiceError | null,
      response: AddSubscriptionResponse,
    ) => void,
  ): ClientUnaryCall;
  removeSubscription(
    request: RemoveSubscriptionRequest,
    callback: (
      error: ServiceError | null,
      response: RemoveSubscriptionResponse,
    ) => void,
  ): ClientUnaryCall;
  removeSubscription(
    request: RemoveSubscriptionRequest,
    metadata: Metadata,
    callback: (
      error: ServiceError | null,
      response: RemoveSubscriptionResponse,
    ) => void,
  ): ClientUnaryCall;
  removeSubscription(
    request: RemoveSubscriptionRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (
      error: ServiceError | null,
      response: RemoveSubscriptionResponse,
    ) => void,
  ): ClientUnaryCall;
  getSubscriptions(
    request: GetSubscriptionsRequest,
    callback: (
      error: ServiceError | null,
      response: GetSubscriptionsResponse,
    ) => void,
  ): ClientUnaryCall;
  getSubscriptions(
    request: GetSubscriptionsRequest,
    metadata: Metadata,
    callback: (
      error: ServiceError | null,
      response: GetSubscriptionsResponse,
    ) => void,
  ): ClientUnaryCall;
  getSubscriptions(
    request: GetSubscriptionsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (
      error: ServiceError | null,
      response: GetSubscriptionsResponse,
    ) => void,
  ): ClientUnaryCall;
}

export const AgentRpcClient = makeGenericClientConstructor(
  AgentRpcService,
  "agents.AgentRpc",
) as unknown as {
  new (
    address: string,
    credentials: ChannelCredentials,
    options?: Partial<ClientOptions>,
  ): AgentRpcClient;
  service: typeof AgentRpcService;
  serviceName: string;
};

function bytesFromBase64(b64: string): Uint8Array {
  return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
}

function base64FromBytes(arr: Uint8Array): string {
  return globalThis.Buffer.from(arr).toString("base64");
}

type Builtin =
  | Date
  | Function
  | Uint8Array
  | string
  | number
  | boolean
  | undefined;

export type DeepPartial<T> = T extends Builtin
  ? T
  : T extends globalThis.Array<infer U>
    ? globalThis.Array<DeepPartial<U>>
    : T extends ReadonlyArray<infer U>
      ? ReadonlyArray<DeepPartial<U>>
      : T extends {}
        ? { [K in keyof T]?: DeepPartial<T[K]> }
        : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin
  ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & {
      [K in Exclude<keyof I, KeysOfUnion<P>>]: never;
    };

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
